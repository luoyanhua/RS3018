C51 COMPILER V9.54   TASK                                                                  05/28/2022 11:17:27 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE TASK
OBJECT MODULE PLACED IN .\list\Task.obj
COMPILER INVOKED BY: D:\keil\keil_C51\C51\BIN\C51.EXE Task.c OPTIMIZE(3,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\list\Ta
                    -sk.lst) OBJECT(.\list\Task.obj)

line level    source

   1          /*---------------------------------------------------------------------*/
   2          /* --- STC MCU Limited ------------------------------------------------*/
   3          /* --- STC 1T Series MCU Demo Programme -------------------------------*/
   4          /* --- Mobile: (86)13922805190 ----------------------------------------*/
   5          /* --- Fax: 86-0513-55012956,55012947,55012969 ------------------------*/
   6          /* --- Tel: 86-0513-55012928,55012929,55012966 ------------------------*/
   7          /* --- Web: www.STCMCU.com --------------------------------------------*/
   8          /* --- Web: www.STCMCUDATA.com  ---------------------------------------*/
   9          /* --- QQ:  800003751 -------------------------------------------------*/
  10          /* »Áπ˚“™‘⁄≥Ã–Ú÷– π”√¥À¥˙¬Î,«Î‘⁄≥Ã–Ú÷–◊¢√˜ π”√¡ÀSTCµƒ◊ ¡œº∞≥Ã–Ú            */
  11          /*---------------------------------------------------------------------*/
  12          
  13          #include "Task.h"
  14          #include "timer.h"
  15          #include "Beep.h"
  16          #include "Task.h"
  17          #include "Sensor.h"
  18          #include "stdio.h"
  19          #include "UART.h"
  20          #include "string.h"
  21          
  22          #define SensorCheck_0 0
  23          #define SensorCheck_1 1
  24          #define SensorCheck_2 2
  25          #define SensorCheck_3 3
  26          #define SensorCheck_4 4
  27          #define SensorCheck_5 5
  28          #define SensorCheck_6 6
  29          #define SensorCheck_7 7
  30          #define SensorCheck_8 8
  31          #define SensorCheck_9 9
  32          
  33          #define WAIT_REV_CMD 10
  34          #define WAIT_STATE 12
  35          #define GET_SENSOR_ID_CNT_MAX 3
  36          
  37          bit sensorIdCheckRunFlag = 0; //‘À––±Í÷æ
  38          bit sensorIdCheckOKFlag = 0;  //≈–∂œOK±Í÷æ
  39          bit ioStatusSaveValueOld = 0; // IOø⁄◊¥Ã¨±£¥Ê
  40          bit ioStatusSaveValueNew = 0; // IOø⁄◊¥Ã¨±£¥Ê
  41          
  42          unsigned char saveTotalSensorID[SENSOR_NUM_MAX] = {0}; //µ±«∞À˘”–…Ë±∏IDŒª÷√,»Áπ˚Œ™”“≤‡¥´∏–∆˜£¨‘Ú◊‘∂®“ÂŒ™÷˜
             -¥´∏–∆˜£¨À≥–Ú∑÷±¥˙±Ì£∫◊Û£¨◊Û÷–£¨”“÷–£¨”“
  43          unsigned char sensorIdCheckState = 0;                  //‘À––◊¥Ã¨ª˙
  44          unsigned int sensorIdCheckTimeCnt = 0;                 //∂® ±∆˜
  45          unsigned char sensorIdGetCnt = 0;                      // ID ªÒ»°º∆ ˝
  46          unsigned char currentSensorID = 0;                     //µ±«∞¥´∏–∆˜÷µ
  47          
  48          unsigned char get_currentSensorID(void)
  49          {
  50   1          return currentSensorID;
  51   1      }
  52          
  53          //≈–∂œ±Í◊º
C51 COMPILER V9.54   TASK                                                                  05/28/2022 11:17:27 PAGE 2   

  54          // P35 ‰≥ˆ∏ﬂµÁ∆Ω£¨»Áπ˚P34µÁ—πŒ™µÕµÁ∆Ω£¨æÕ «◊Û,”“¥´∏–∆˜£ª»Áπ˚P34Œ™∏ﬂµÁ∆ΩæÕ «◊Û÷–£¨”“÷–
  55          // P35 ‰≥ˆµÕµÁ∆Ω£¨»Áπ˚P34µÁ—πŒ™µÕµÁ∆Ω£¨æÕ «◊Û£¨”“÷–¥´∏–∆˜£¨»Áπ˚P34Œ™∏ﬂµÁ∆Ω£¨æÕ «”“£¨◊Û÷–¥´∏–∆˜°£
  56          //¡Ω¥ŒµÁ∆Ωœ‡µ»∫„µÕæÕ «◊Û÷–£¨∫„∏ﬂæÕ «◊Û£ª¡Ω¥ŒµÁ∆Ω≤ªµ»£¨µ´”ÎP35µÁ∆Ωœ‡µ»æÕ «”“÷–£¨”ÎP35µÁ∆Ω≤ªµ»æÕ «”“°£
  57          
  58          void sensorIdAdjustTask(void)
  59          {
  60   1          if (sensorIdCheckRunFlag == 1)
  61   1              return;
  62   1          switch (sensorIdCheckState)
  63   1          {
  64   2      
  65   2          case SensorCheck_0:
  66   2              PWM_OUTPUT = HIGH;
  67   2              sensorIdCheckTimeCnt = Get_SysHalfMsTick(); //À¢–¬º∆ ±∆˜
  68   2              sensorIdCheckState = SensorCheck_1;
  69   2              break;
  70   2          case SensorCheck_1:
  71   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 20) // µ»¥˝20ms
  72   2              {
  73   3                  ioStatusSaveValueOld = SENSOR_ID_CHECK; //º«¬ºSENSOR_ID_CHECKµÁ∆Ω
  74   3                  sensorIdCheckState = SensorCheck_2;
  75   3              }
  76   2              break;
  77   2          case SensorCheck_2:
  78   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 50) // µ»¥˝30ms∫Û‘Ÿ∑¥◊™µÁ∆Ω£
             -¨±‹√‚µÁ∆Ω≥ÂÕª
  79   2              {
  80   3                  PWM_OUTPUT = LOW;
  81   3                  sensorIdCheckState = SensorCheck_3;
  82   3              }
  83   2              break;
  84   2          case SensorCheck_3:
  85   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 100) // 50ms≥¨ ±∫ÛºÃ–¯Õ˘œ¬Ω¯
             -––
  86   2              {
  87   3                  ioStatusSaveValueNew = SENSOR_ID_CHECK; //º«¬ºSENSOR_ID_CHECKµÁ∆Ω
  88   3                  if (SENSOR_ID_CHECK == LOW)
  89   3                  {
  90   4                      if (ioStatusSaveValueNew == ioStatusSaveValueOld) //¡Ω¥ŒSENSOR_ID_CHECKµÁ∆Ωœ‡µ»∫„µÕ
  91   4                      {
  92   5                          currentSensorID = LEFT_MID_SENSOR;
  93   5                      }
  94   4                      else //¡Ω¥ŒµÁ∆Ω≤ªµ»£¨µ´”ÎP35µÁ∆Ωœ‡µ»æÕ «”“÷–
  95   4                      {
  96   5                          currentSensorID = RIGHT_MID_SENSOR;
  97   5                      }
  98   4                  }
  99   3                  else
 100   3                  {
 101   4                      if (ioStatusSaveValueNew == ioStatusSaveValueOld) //¡Ω¥ŒSENSOR_ID_CHECKµÁ∆Ωœ‡µ»∫„∏ﬂ
 102   4                      {
 103   5                          currentSensorID = LEFT_SENSOR;
 104   5                      }
 105   4                      else //¡Ω¥ŒµÁ∆Ω≤ªµ»£¨”ÎP35µÁ∆Ω≤ªµ»æÕ «”“
 106   4                      {
 107   5                          if(SENSOR_ID_RX == 0)
 108   5                          {
 109   6                              currentSensorID = RIGHT_MID_SENSOR;
 110   6                          }
 111   5                          else
 112   5                          {
 113   6                              currentSensorID = RIGHT_SENSOR;
C51 COMPILER V9.54   TASK                                                                  05/28/2022 11:17:27 PAGE 3   

 114   6                          }                  
 115   5                      }
 116   4                  }
 117   3                  sensorIdCheckState = SensorCheck_4;
 118   3                  UART_config();
 119   3              }
 120   2              break;
 121   2          case SensorCheck_4:
 122   2              if (currentSensorID == RIGHT_SENSOR) //»Áπ˚ «”“¥´∏–∆˜–Ë“™∏˙∆‰À˚¥´∏–∆˜Õ®–≈
 123   2              {
 124   3                  getSensorImfo(RIGHT_MID_SENSOR, CMD_ID);
 125   3                  sensorIdCheckState = SensorCheck_5;
 126   3                  sensorIdCheckTimeCnt = Get_SysHalfMsTick(); //À¢–¬º∆ ±∆˜
 127   3              }
 128   2              else //≤ª «”“¥´∏–∆˜£¨µ»¥˝Ω” ’ ˝æ›
 129   2              {
 130   3                  sensorIdCheckState = WAIT_REV_CMD;
 131   3              }
 132   2              break;
 133   2          case SensorCheck_5:                                                           //≈–∂œ «∑Ò ’µΩ”“÷–ÃΩÕ∑ID
             -–≈œ¢
 134   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 50) // 50ms≥¨ ±∫ÛºÃ–¯Õ˘œ¬Ω¯–
             -–
 135   2              {
 136   3                  if (analysisSensorImfo())
 137   3                  {
 138   4                      // ’µΩ”“÷–ÃΩÕ∑ID–≈œ¢
 139   4                      saveTotalSensorID[2] = 1;
 140   4                      sensorIdGetCnt = 0;
 141   4                      sensorIdCheckState = SensorCheck_6;
 142   4                  }
 143   3                  else
 144   3                  {
 145   4                      sensorIdGetCnt++;
 146   4                      sensorIdCheckState = SensorCheck_4;
 147   4                      if (sensorIdGetCnt >= GET_SENSOR_ID_CNT_MAX)
 148   4                      {
 149   5                          sensorIdGetCnt = 0;
 150   5                          sensorIdCheckState = SensorCheck_6;
 151   5                      }
 152   4                  }
 153   3              }
 154   2              break;
 155   2          case SensorCheck_6:                     //∑¢ÀÕªÒ»°◊Û≤‡ÃΩÕ∑–≈œ¢÷∏¡Ó
 156   2              getSensorImfo(LEFT_SENSOR, CMD_ID); //∑¢ÀÕªÒ»°◊Û≤‡ÃΩÕ∑–≈œ¢÷∏¡Ó
 157   2              sensorIdCheckState = SensorCheck_7;
 158   2              sensorIdCheckTimeCnt = Get_SysHalfMsTick(); //À¢–¬º∆ ±∆˜
 159   2              break;
 160   2          case SensorCheck_7:                                                           //≈–∂œ «∑Ò ’µΩ◊Û≤‡ÃΩÕ∑ID
             -–≈œ¢
 161   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 50) // 50ms≥¨ ±∫ÛºÃ–¯Õ˘œ¬Ω¯–
             -–
 162   2              {
 163   3                  if (analysisSensorImfo())
 164   3                  {
 165   4                      // ’µΩ◊Û≤‡ÃΩÕ∑ID–≈œ¢
 166   4                      saveTotalSensorID[0] = 1;
 167   4                      sensorIdGetCnt = 0;
 168   4                      sensorIdCheckState = SensorCheck_8;
 169   4                  }
 170   3                  else
 171   3                  {
C51 COMPILER V9.54   TASK                                                                  05/28/2022 11:17:27 PAGE 4   

 172   4                      sensorIdGetCnt++;
 173   4                      sensorIdCheckState = SensorCheck_6;
 174   4                      if (sensorIdGetCnt >= GET_SENSOR_ID_CNT_MAX)
 175   4                      {
 176   5                          sensorIdGetCnt = 0;
 177   5                          sensorIdCheckState = SensorCheck_8;
 178   5                      }
 179   4                  }
 180   3              }
 181   2              break;
 182   2          case SensorCheck_8:                         //∑¢ÀÕªÒ»°◊Û÷–ÃΩÕ∑–≈œ¢÷∏¡Ó
 183   2              getSensorImfo(LEFT_MID_SENSOR, CMD_ID); //∑¢ÀÕªÒ»°◊Û÷–ÃΩÕ∑–≈œ¢÷∏¡Ó
 184   2              sensorIdCheckState = SensorCheck_9;
 185   2              sensorIdCheckTimeCnt = Get_SysHalfMsTick(); //À¢–¬º∆ ±∆˜
 186   2              break;
 187   2          case SensorCheck_9:                                                           //≈–∂œ «∑Ò ’µΩ◊Û÷–ÃΩÕ∑ID
             -–≈œ¢
 188   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 50) // 50ms≥¨ ±∫ÛºÃ–¯Õ˘œ¬Ω¯–
             -–
 189   2              {
 190   3                  if (analysisSensorImfo())
 191   3                  {
 192   4                      // ’µΩ◊Û÷–ÃΩÕ∑ID–≈œ¢
 193   4                      saveTotalSensorID[1] = 1;
 194   4                      sensorIdGetCnt = 0;
 195   4                      sensorIdCheckState = WAIT_STATE;
 196   4                  }
 197   3                  else
 198   3                  {
 199   4                      sensorIdGetCnt++;
 200   4                      sensorIdCheckState = SensorCheck_8;
 201   4                      if (sensorIdGetCnt >= GET_SENSOR_ID_CNT_MAX)
 202   4                      {
 203   5                          sensorIdGetCnt = 0;
 204   5                          sensorIdCheckState = WAIT_STATE;
 205   5                      }
 206   4                  }
 207   3              }
 208   2              break;
 209   2          case WAIT_REV_CMD:                                                             //Ω¯»Î’‚¿Ô£¨±ÿ»ª≤ª «”“¥
             -´∏–∆˜
 210   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 600) // 600ms≥¨ ±∫ÛºÃ–¯Õ˘œ¬Ω
             -¯––
 211   2              {
 212   3                  sensorIdCheckState = WAIT_STATE;
 213   3              }
 214   2              else
 215   2              {
 216   3                  if (analysisSensorImfo()) // «∑Ò ’µΩªÒ»°Œª÷√–≈œ¢÷∏¡Ó
 217   3                  {
 218   4                      //Ω‚Œˆªÿ∏¥ ˝æ›
 219   4                      sensorIdCheckState = WAIT_STATE;
 220   4                  }
 221   3              }
 222   2              break;
 223   2          case WAIT_STATE: // ≈–∂œ◊Û≤‡ÃΩÕ∑Œª÷√
 224   2              sensorIdCheckState = 0;
 225   2              sensorIdCheckRunFlag = 1; //ÃΩÕ∑Œª÷√ ∂±ÕÍ≥…
 226   2              break;
 227   2          }
 228   1      }
 229          
C51 COMPILER V9.54   TASK                                                                  05/28/2022 11:17:27 PAGE 5   

 230          unsigned char appTaskState = 0;
 231          unsigned int appTaskTimeCnt = 0;
 232          
 233          void AppTask(void)
 234          {
 235   1          if (sensorIdCheckRunFlag == 0)
 236   1              return;
 237   1          switch (appTaskState)
 238   1          {
 239   2          case 0: //∑¢ÀÕPWM 150ms ”√¿¥»∑»œŒª÷√–≈∫≈
 240   2              StartBeepAlarm(150, 0);
 241   2              appTaskTimeCnt = Get_SysHalfMsTick();
 242   2              appTaskState = 1;
 243   2              break;
 244   2          case 1: // Sensor IDª· ’µΩ◊‘º∫∑¢µƒ–≈∫≈
 245   2              if (SENSOR_ID_CHECK == 0)
 246   2              {
 247   3                  VirtualCOM_StringSend("recv ID!\r\n"); // UART1∑¢ÀÕ“ª∏ˆ◊÷∑˚¥Æ
 248   3                  appTaskState = 2;
 249   3              }
 250   2              else if (get_time_escape_sec(Get_SysHalfMsTick(), appTaskTimeCnt) >= 20) // 10ms≥¨ ±∫ÛºÃ–¯Õ˘œ¬Ω¯––
 251   2              {
 252   3                  VirtualCOM_StringSend("recv ID timeout!\r\n"); // UART1∑¢ÀÕ“ª∏ˆ◊÷∑˚¥Æ
 253   3                  appTaskState = 2;
 254   3              }
 255   2              break;
 256   2          case 2: //ø™ª˙ÃΩÕ∑◊‘ºÏ
 257   2              Start_sendOncePlusTask();
 258   2              appTaskState = 3;
 259   2              VirtualCOM_StringSend("sensor self check!\r\n"); // UART1∑¢ÀÕ“ª∏ˆ◊÷∑˚¥Æ
 260   2              break;
 261   2          case 3: //ªÒ»°ÃΩÕ∑◊‘ºÏΩ·π˚
 262   2              if (Get_SendOncePlusTaskFlag() == 0)
 263   2              {
 264   3                  if (Get_sensorOkFlag())
 265   3                  {
 266   4                      VirtualCOM_StringSend("sensor is ok!\r\n"); // UART1∑¢ÀÕ“ª∏ˆ◊÷∑˚¥Æ
 267   4                      appTaskState = 4;                           //ºÏ≤‚µΩÃΩÕ∑
 268   4                  }
 269   3                  else
 270   3                  {
 271   4                      VirtualCOM_StringSend("No sensor!\r\n"); // UART1∑¢ÀÕ“ª∏ˆ◊÷∑˚¥Æ
 272   4                      appTaskState = 0;                        //ŒﬁÃΩÕ∑¥”Õ∑ø™ º
 273   4                  }
 274   3              }
 275   2              break;
 276   2          case 4: //ø™ º≤‚æ‡Ω·π˚
 277   2              appTaskTimeCnt = Get_SysHalfMsTick();
 278   2              Start_sendOncePlusTask();
 279   2              appTaskState = 5;
 280   2              break;
 281   2          case 5: //≈–∂œ «∑Ò”–’œ∞≠ŒÔ
 282   2              if (Get_SendOncePlusTaskFlag() == 0)
 283   2              {
 284   3                  if (Get_obstaclesExistenceFlag()) //”–’œ∞≠ŒÔ
 285   3                  {
 286   4                      if (get_time_escape_sec(Get_SysHalfMsTick(), appTaskTimeCnt) >= 100) // µ»¥˝50ms
 287   4                      {
 288   5                          VirtualCOM_StringSend("obstacle!\r\n"); // UART1∑¢ÀÕ“ª∏ˆ◊÷∑˚¥Æ
 289   5                          appTaskState = 4;
 290   5                          sensorIdCheckOKFlag = 1;
 291   5                      }
C51 COMPILER V9.54   TASK                                                                  05/28/2022 11:17:27 PAGE 6   

 292   4                  }
 293   3                  else //√ª”–’œ∞≠ŒÔ
 294   3                  {
 295   4                      if (get_time_escape_sec(Get_SysHalfMsTick(), appTaskTimeCnt) >= 400) // 200ms≤‚ ‘“ª¥Œ
 296   4                      {
 297   5                          //ªÒ»°≤‚ ‘æ‡¿Î
 298   5                          VirtualCOM_StringSend("No obstacles!\r\n"); // UART1∑¢ÀÕ“ª∏ˆ◊÷∑˚¥Æ
 299   5                          appTaskState = 4;
 300   5                          sensorIdCheckOKFlag = 1;
 301   5                      }
 302   4                  }
 303   3              }
 304   2              break;
 305   2          default:
 306   2              break;
 307   2          }
 308   1      }
 309          
 310          unsigned char sensorDistanceGetState = 0;  // æ‡¿ÎªÒ»°◊¥Ã¨ª˙
 311          unsigned int sensorDistanceGetTimeCnt = 0; //æ‡¿ÎªÒ»°∂® ±∆˜
 312          
 313          void sensorDistanceGetTask(void)
 314          {
 315   1          if (sensorIdCheckOKFlag == 0)
 316   1              return;
 317   1          switch (sensorDistanceGetState)
 318   1          {
 319   2          case 0:
 320   2              if (currentSensorID == RIGHT_SENSOR) //»Áπ˚ «”“¥´∏–∆˜–Ë“™∏˙∆‰À˚¥´∏–∆˜Õ®–≈
 321   2              {
 322   3                  getSensorImfo(RIGHT_MID_SENSOR, CMD_DISTANCE);
 323   3                  sensorDistanceGetState = 1;
 324   3                  sensorDistanceGetTimeCnt = Get_SysHalfMsTick(); //À¢–¬º∆ ±∆˜
 325   3              }
 326   2              else //≤ª «”“¥´∏–∆˜£¨µ»¥˝Ω” ’ ˝æ›
 327   2              {
 328   3                  sensorDistanceGetState = 7;
 329   3              }
 330   2              break;
 331   2          case 1:                                                                           //≈–∂œ «∑Ò ’µΩ”“÷–ÃΩ
             -Õ∑ID–≈œ¢
 332   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorDistanceGetTimeCnt) >= 40) // 20ms≥¨ ±∫ÛºÃ–¯Õ˘œ
             -¬Ω¯––
 333   2              {
 334   3                  if (analysisSensorImfo())
 335   3                  {
 336   4                      // ’µΩ”“÷–ÃΩÕ∑æ‡¿Î–≈œ¢£¨±£¥Ê
 337   4                  }
 338   3                  else //«Â≥˛æ‡¿Î–≈œ¢
 339   3                  {
 340   4                  }
 341   3                  sensorDistanceGetState = 2;
 342   3              }
 343   2              break;
 344   2          case 2:                                       //∑¢ÀÕªÒ»°◊Û≤‡ÃΩÕ∑–≈œ¢÷∏¡Ó
 345   2              getSensorImfo(LEFT_SENSOR, CMD_DISTANCE); //∑¢ÀÕªÒ»°◊Û≤‡ÃΩÕ∑–≈œ¢÷∏¡Ó
 346   2              sensorDistanceGetState = 3;
 347   2              sensorDistanceGetTimeCnt = Get_SysHalfMsTick(); //À¢–¬º∆ ±∆˜
 348   2              break;
 349   2          case 3:                                                                           //≈–∂œ «∑Ò ’µΩ◊Û≤‡ÃΩ
             -Õ∑ID–≈œ¢
 350   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorDistanceGetTimeCnt) >= 40) // 20ms≥¨ ±∫ÛºÃ–¯Õ˘œ
C51 COMPILER V9.54   TASK                                                                  05/28/2022 11:17:27 PAGE 7   

             -¬Ω¯––
 351   2              {
 352   3                  if (analysisSensorImfo())
 353   3                  {
 354   4                      // ’µΩ◊Û≤‡ÃΩÕ∑æ‡¿Î–≈œ¢
 355   4                  }
 356   3                  else //«Â≥˛æ‡¿Î–≈œ¢
 357   3                  {
 358   4                  }
 359   3                  sensorDistanceGetState = 4;
 360   3              }
 361   2              break;
 362   2          case 4:                                           //∑¢ÀÕªÒ»°◊Û÷–ÃΩÕ∑–≈œ¢÷∏¡Ó
 363   2              getSensorImfo(LEFT_MID_SENSOR, CMD_DISTANCE); //∑¢ÀÕªÒ»°◊Û÷–ÃΩÕ∑–≈œ¢÷∏¡Ó
 364   2              sensorDistanceGetState = 5;
 365   2              sensorDistanceGetTimeCnt = Get_SysHalfMsTick(); //À¢–¬º∆ ±∆˜
 366   2              break;
 367   2          case 5:                                                                           //≈–∂œ «∑Ò ’µΩ◊Û÷–ÃΩ
             -Õ∑ID–≈œ¢
 368   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorDistanceGetTimeCnt) >= 40) // 20ms≥¨ ±∫ÛºÃ–¯Õ˘œ
             -¬Ω¯––
 369   2              {
 370   3                  if (analysisSensorImfo())
 371   3                  {
 372   4                      // ’µΩ◊Û÷–ÃΩÕ∑æ‡¿Î–≈œ¢
 373   4                  }
 374   3                  else //«Â≥˛æ‡¿Î–≈œ¢
 375   3                  {
 376   4                  }
 377   3                  sensorDistanceGetState = 6;
 378   3              }
 379   2              break;
 380   2          case 6:                                                                           //≈–∂œ «∑Ò ’µΩ◊Û÷–ÃΩ
             -Õ∑ID–≈œ¢
 381   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorDistanceGetTimeCnt) >= 40) // 20ms≥¨ ±∫ÛºÃ–¯Õ˘œ
             -¬Ω¯––
 382   2              {
 383   3                  //∑¢ÀÕ“ª∞¸¥¯∑ΩŒªæ‡¿Î–≈œ¢µƒ ˝æ›
 384   3                  sensorTotalPackage();
 385   3                  sensorDistanceGetState = 0;
 386   3              }
 387   2              break;
 388   2          case 7:                       //Ω¯»Î’‚¿Ô£¨±ÿ»ª≤ª «”“¥´∏–∆˜
 389   2              if (analysisSensorImfo()) // «∑Ò ’µΩªÒ»°Œª÷√–≈œ¢÷∏¡Ó
 390   2              {
 391   3                  //Ω‚Œˆªÿ∏¥ ˝æ›
 392   3                  sensorDistanceGetState = 0;
 393   3              }
 394   2              break;
 395   2          }
 396   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    941    ----
   CONSTANT SIZE    =    108    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     15    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.54   TASK                                                                  05/28/2022 11:17:27 PAGE 8   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
