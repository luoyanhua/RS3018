C51 COMPILER V9.54   TASK                                                                  04/16/2022 12:05:24 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE TASK
OBJECT MODULE PLACED IN .\list\Task.obj
COMPILER INVOKED BY: D:\keil\keil_C51\C51\BIN\C51.EXE Task.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\list\Ta
                    -sk.lst) OBJECT(.\list\Task.obj)

line level    source

   1          /*---------------------------------------------------------------------*/
   2          /* --- STC MCU Limited ------------------------------------------------*/
   3          /* --- STC 1T Series MCU Demo Programme -------------------------------*/
   4          /* --- Mobile: (86)13922805190 ----------------------------------------*/
   5          /* --- Fax: 86-0513-55012956,55012947,55012969 ------------------------*/
   6          /* --- Tel: 86-0513-55012928,55012929,55012966 ------------------------*/
   7          /* --- Web: www.STCMCU.com --------------------------------------------*/
   8          /* --- Web: www.STCMCUDATA.com  ---------------------------------------*/
   9          /* --- QQ:  800003751 -------------------------------------------------*/
  10          /* Èç¹ûÒªÔÚ³ÌÐòÖÐÊ¹ÓÃ´Ë´úÂë,ÇëÔÚ³ÌÐòÖÐ×¢Ã÷Ê¹ÓÃÁËSTCµÄ×ÊÁÏ¼°³ÌÐò            */
  11          /*---------------------------------------------------------------------*/
  12          
  13          #include "Task.h"
  14          #include "timer.h"
  15          #include "Beep.h"
  16          #include "Task.h"
  17          #include "Sensor.h"
  18          #include "UART.h"
  19          #include "stdio.h"
  20          #include "string.h"
  21          
  22          #define SENSOR_NUM_MAX 4
  23          
  24          typedef struct
  25          {
  26              bit runFlag;                           //ÔËÐÐ±êÖ¾
  27              bit adjustOKFlag;                      //ÅÐ¶ÏOK±êÖ¾
  28              bit ioStatusSaveValue;                 // IO¿Ú×´Ì¬±£´æ
  29              bit saveTotalSensorID[SENSOR_NUM_MAX]; //µ±Ç°ËùÓÐÉè±¸IDÎ»ÖÃ,Èç¹ûÎªÓÒ²à´«¸ÐÆ÷£¬Ôò×Ô¶¨ÒåÎªÖ÷´«¸ÐÆ÷
*** ERROR C168 IN LINE 29 OF Task.c: 'saveTotalSensorID': array of bit
  30              unsigned char state;                   //ÔËÐÐ×´Ì¬»ú
  31              unsigned int TimeCnt;                  //¶¨Ê±Æ÷
  32          } sensorIdAdjustStruct_T;
*** ERROR C150 IN LINE 32 OF Task.c: 'runFlag': bit member in struct/union
*** ERROR C150 IN LINE 32 OF Task.c: 'adjustOKFlag': bit member in struct/union
*** ERROR C150 IN LINE 32 OF Task.c: 'ioStatusSaveValue': bit member in struct/union
  33          
  34          sensorIdAdjustStruct_T sensorIdAdjustStruct;
  35          
  36          void sensorIdAdjustTask_init(void)
  37          {
  38   1          memset(&sensorIdAdjustStruct, 0, sizeof(sensorIdAdjustStruct));
  39   1      }
  40          
  41          unsigned char appTaskState = 0;
  42          unsigned int appTaskTimeCnt = 0;
  43          
  44          void sensorIdAdjustTask(void)
  45          {
  46   1          if (sensorIdAdjustStruct.runFlag == 1)
  47   1              return;
  48   1          switch (sensorIdAdjustStruct.state)
  49   1          {
  50   2          case 0: //·¢ËÍPWM 150ms ÓÃÀ´È·ÈÏÎ»ÖÃÐÅºÅ
C51 COMPILER V9.54   TASK                                                                  04/16/2022 12:05:24 PAGE 2   

  51   2              StartBeepAlarm(150);
  52   2              sensorIdAdjustStruct.TimeCnt = Get_SysHalfMsTick(); //¿ªÆô¼ÆÊ±Æ÷
  53   2              sensorIdAdjustStruct.state = 1;
  54   2              break;
  55   2          case 1: // ÅÐ¶ÏÓÒÖÐÌ½Í·Î»ÖÃ£¬Ö»ÓÐÓÒ²àÌ½Í·»áÊÕµ½×Ô¼º·¢µÄÐÅºÅ
  56   2              //¿ªÆôP10½ÓÊÕPWM
  57   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdAdjustStruct.TimeCnt) >= 200) // 200ms³¬Ê±ºó¼
             -ÌÐøÍùÏÂ½øÐÐ
  58   2              {
  59   3                  if (sensorIdAdjustStruct.adjustOKFlag == 1) //ÊÕµ½PWM
  60   3                  {
  61   4                      sensorIdAdjustStruct.adjustOKFlag = 0;
  62   4                      uartSendPackage(PWM_CHECK); //¶¨Òå×Ô¼ºÎªÓÒÖÐÌ½Í·£¬·¢ËÍÓÒÖÐÌ½Í·µÄIDÊ¶±ðÐÅÏ¢
  63   4                  }
  64   3                  sensorIdAdjustStruct.state = 2;
  65   3              }
  66   2              else
  67   2              {
  68   3                  if (P10 == 1)
  69   3                  {
  70   4                      sensorIdAdjustStruct.ioStatusSaveValue = 1;
  71   4                  }
  72   3                  if (sensorIdAdjustStruct.ioStatusSaveValue == 1 && P10 == 0)
  73   3                  {
  74   4                      sensorIdAdjustStruct.adjustOKFlag = 1;
  75   4                  }
  76   3              }
  77   2              break;
  78   2          case 2:                                                                                // ÅÐ¶ÏÓÒ²àÌ½Í·
             -Î»ÖÃ
  79   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdAdjustStruct.TimeCnt) >= 400) // 200ms³¬Ê±ºó¼
             -ÌÐøÍùÏÂ½øÐÐ
  80   2              {
  81   3                  if (getRxSensorId() == 4) //ÊÕµ½ÓÒÖÐÌ½Í·µÄIDÊ¶±ðÐÅÏ¢
  82   3                  {
  83   4                      sensorIdAdjustStruct.ioStatusSaveValue = 1;
  84   4                      uartSendPackage(SELF_CHECK);    //¶¨Òå×Ô¼ºÎªÓÒ²àÌ½Í·£¬·¢ËÍÓÒ²àÌ½Í·Éí·Ý
  85   4                      sensorIdAdjustStruct.state = 5; //Ìø×ªµ½µÈ´ý1S¼ÆÊ±Íê³É
  86   4                  }
  87   3                  else
  88   3                  {
  89   4                      sensorIdAdjustStruct.state = 3;
  90   4                  }
  91   3              }
  92   2              break;
  93   2          case 3:                                                                                // ÅÐ¶Ï×óÖÐÌ½Í·
             -Î»ÖÃ
  94   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdAdjustStruct.TimeCnt) >= 600) // 200ms³¬Ê±ºó¼
             -ÌÐøÍùÏÂ½øÐÐ
  95   2              {
  96   3                  if (sensorIdAdjustStruct.adjustOKFlag == 1) //ÅÐ¶ÏÁ¬ÐøµÍµçÆ½£¬×óÖÐ
  97   3                  {
  98   4      
  99   4                      uartSendPackage(SELF_CHECK);    //¶¨Òå×Ô¼ºÎª×óÖÐÌ½Í·£¬·¢ËÍ×óÖÐÌ½Í·Éí·Ý
 100   4                      sensorIdAdjustStruct.state = 5; //Ìø×ªµ½µÈ´ý1S¼ÆÊ±Íê³É
 101   4                  }
 102   3                  else
 103   3                  {
 104   4                      sensorIdAdjustStruct.state = 4;
 105   4                  }
 106   3              }
 107   2              else
C51 COMPILER V9.54   TASK                                                                  04/16/2022 12:05:24 PAGE 3   

 108   2              {
 109   3                  if (P10 == 1)
 110   3                  {
 111   4                      sensorIdAdjustStruct.adjustOKFlag = 0;
 112   4                  }
 113   3              }
 114   2              break;
 115   2          case 4:                                                                                // ÅÐ¶Ï×ó²àÌ½Í·
             -Î»ÖÃ
 116   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdAdjustStruct.TimeCnt) >= 800) // 200ms³¬Ê±ºó¼
             -ÌÐøÍùÏÂ½øÐÐ
 117   2              {
 118   3                  if (sensorIdAdjustStruct.adjustOKFlag == 1) //ÅÐ¶ÏÁ¬Ðø¸ßµçÆ½£¬×ó±ß
 119   3                  {
 120   4                      uartSendPackage(SELF_CHECK);    //¶¨Òå×Ô¼ºÎª×ó²àÌ½Í·£¬·¢ËÍ×ó²àÌ½Í·Éí·Ý
 121   4                      sensorIdAdjustStruct.state = 5; //Ìø×ªµ½µÈ´ý1S¼ÆÊ±Íê³É
 122   4                  }
 123   3                  else
 124   3                  {
 125   4                      sensorIdAdjustStruct.state = 4;
 126   4                  }
 127   3              }
 128   2              else
 129   2              {
 130   3                  if (P10 == 0)
 131   3                  {
 132   4                      sensorIdAdjustStruct.adjustOKFlag = 0;
 133   4                  }
 134   3              }
 135   2              break;
 136   2          case 5: // ÅÐ¶Ï×ó²àÌ½Í·Î»ÖÃ
 137   2              sensorIdAdjustStruct.state = 0;
 138   2              sensorIdAdjustStruct.runFlag = 1; //Ì½Í·Î»ÖÃÊ¶±ðÍê³É
 139   2              break;
 140   2          }
 141   1      }
 142          
 143          void AppTask(void)
 144          {
 145   1          if (sensorIdAdjustStruct.runFlag == 0)
 146   1              return;
 147   1          switch (appTaskState)
 148   1          {
 149   2          case 0: //·¢ËÍPWM 150ms ÓÃÀ´È·ÈÏÎ»ÖÃÐÅºÅ
 150   2              StartBeepAlarm(150);
 151   2              appTaskTimeCnt = Get_SysHalfMsTick();
 152   2              appTaskState = 1;
 153   2              break;
 154   2          case 1: // Sensor ID»áÊÕµ½×Ô¼º·¢µÄÐÅºÅ
 155   2              if (P34 == 0)
 156   2              {
 157   3                  VirtualCOM_StringSend("recv ID!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 158   3                  appTaskState = 2;
 159   3              }
 160   2              else if (get_time_escape_sec(Get_SysHalfMsTick(), appTaskTimeCnt) >= 20) // 10ms³¬Ê±ºó¼ÌÐøÍùÏÂ½øÐÐ
 161   2              {
 162   3                  VirtualCOM_StringSend("recv ID timeout!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 163   3                  appTaskState = 2;
 164   3              }
 165   2              break;
 166   2          case 2: //¿ª»úÌ½Í·×Ô¼ì
 167   2              Start_sendOncePlusTask();
C51 COMPILER V9.54   TASK                                                                  04/16/2022 12:05:24 PAGE 4   

 168   2              appTaskState = 3;
 169   2              VirtualCOM_StringSend("sensor self check!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 170   2              break;
 171   2          case 3: //»ñÈ¡Ì½Í·×Ô¼ì½á¹û
 172   2              if (Get_SendOncePlusTaskFlag() == 0)
 173   2              {
 174   3                  if (Get_sensorOkFlag())
 175   3                  {
 176   4                      VirtualCOM_StringSend("sensor is ok!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 177   4                      appTaskState = 4;                           //¼ì²âµ½Ì½Í·
 178   4                  }
 179   3                  else
 180   3                  {
 181   4                      VirtualCOM_StringSend("No sensor!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 182   4                      appTaskState = 0;                        //ÎÞÌ½Í·´ÓÍ·¿ªÊ¼
 183   4                  }
 184   3                  uartSendPackage(SELF_CHECK);
 185   3              }
 186   2              break;
 187   2          case 4: //¿ªÊ¼²â¾à½á¹û
 188   2              appTaskTimeCnt = Get_SysHalfMsTick();
 189   2              Start_sendOncePlusTask();
 190   2              appTaskState = 5;
 191   2              break;
 192   2          case 5: //ÅÐ¶ÏÊÇ·ñÓÐÕÏ°­Îï
 193   2              if (Get_SendOncePlusTaskFlag() == 0)
 194   2              {
 195   3                  if (Get_obstaclesExistenceFlag()) //ÓÐÕÏ°­Îï
 196   3                  {
 197   4                      if (get_time_escape_sec(Get_SysHalfMsTick(), appTaskTimeCnt) >= 100) // 50ms²âÊÔÒ»´Î
 198   4                      {
 199   5                          VirtualCOM_StringSend("obstacle!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 200   5                          appTaskState = 4;
 201   5                          uartSendPackage(NOM_WORK);
 202   5                      }
 203   4                  }
 204   3                  else //Ã»ÓÐÕÏ°­Îï
 205   3                  {
 206   4                      if (get_time_escape_sec(Get_SysHalfMsTick(), appTaskTimeCnt) >= 400) // 200ms²âÊÔÒ»´Î
 207   4                      {
 208   5                          //»ñÈ¡²âÊÔ¾àÀë
 209   5                          VirtualCOM_StringSend("No obstacles!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 210   5                          appTaskState = 4;
 211   5                          uartSendPackage(NOM_WORK);
 212   5                      }
 213   4                  }
 214   3              }
 215   2              break;
 216   2          default:
 217   2              break;
 218   2          }
 219   1      }

C51 COMPILATION COMPLETE.  0 WARNING(S),  4 ERROR(S)
