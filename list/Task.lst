<<<<<<< HEAD
C51 COMPILER V9.54   TASK                                                                  05/17/2022 22:00:16 PAGE 1   
=======
C51 COMPILER V9.54   TASK                                                                  04/23/2022 08:59:35 PAGE 1   
>>>>>>> ac9b71b636d5bf0dc7d832531626a13307726cd8


C51 COMPILER V9.54, COMPILATION OF MODULE TASK
OBJECT MODULE PLACED IN .\list\Task.obj
COMPILER INVOKED BY: D:\keil\keil_C51\C51\BIN\C51.EXE Task.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\list\Ta
                    -sk.lst) OBJECT(.\list\Task.obj)

line level    source

   1          /*---------------------------------------------------------------------*/
   2          /* --- STC MCU Limited ------------------------------------------------*/
   3          /* --- STC 1T Series MCU Demo Programme -------------------------------*/
   4          /* --- Mobile: (86)13922805190 ----------------------------------------*/
   5          /* --- Fax: 86-0513-55012956,55012947,55012969 ------------------------*/
   6          /* --- Tel: 86-0513-55012928,55012929,55012966 ------------------------*/
   7          /* --- Web: www.STCMCU.com --------------------------------------------*/
   8          /* --- Web: www.STCMCUDATA.com  ---------------------------------------*/
   9          /* --- QQ:  800003751 -------------------------------------------------*/
  10          /* Èç¹ûÒªÔÚ³ÌÐòÖÐÊ¹ÓÃ´Ë´úÂë,ÇëÔÚ³ÌÐòÖÐ×¢Ã÷Ê¹ÓÃÁËSTCµÄ×ÊÁÏ¼°³ÌÐò            */
  11          /*---------------------------------------------------------------------*/
  12          
  13          #include "Task.h"
  14          #include "timer.h"
  15          #include "Beep.h"
  16          #include "Task.h"
  17          #include "Sensor.h"
  18          #include "stdio.h"
  19          #include "UART.h"
  20          #include "string.h"
  21          
<<<<<<< HEAD
  22          #define SensorCheck_0 0
  23          #define SensorCheck_1 1
  24          #define SensorCheck_2 2
  25          #define SensorCheck_3 3
  26          #define SensorCheck_4 4
  27          #define SensorCheck_5 5
  28          #define SensorCheck_6 6
  29          #define SensorCheck_7 7
  30          #define SensorCheck_8 8
  31          #define SensorCheck_9 9
  32          
  33          #define WAIT_REV_CMD 10
  34          #define WAIT_STATE 12
  35          #define GET_SENSOR_ID_CNT_MAX 3
  36          
  37          bit sensorIdCheckRunFlag = 0;                          //ÔËÐÐ±êÖ¾
  38          bit sensorIdCheckOKFlag = 0;                           //ÅÐ¶ÏOK±êÖ¾
  39          bit ioStatusSaveValueOld = 0;                             // IO¿Ú×´Ì¬±£´æ
  40          bit ioStatusSaveValueNew = 0;                             // IO¿Ú×´Ì¬±£´æ
=======
  22          #define RightSensorCheck_0 0
  23          #define RightSensorCheck_1 1
  24          #define RightSensorCheck_2 2
  25          #define RightSensorCheck_3 3
  26          #define RightSensorCheck_4 4
  27          #define RightSensorCheck_5 5
  28          #define RightSensorCheck_6 6
  29          #define RightSensorCheck_7 7
  30          #define RightSensorCheck_8 8
  31          #define RightSensorCheck_9 9
  32          
  33          #define WAIT_REV_CMD 10
  34          #define WAIT_STATE 12
  35          
  36          #define GET_SENSOR_ID_CNT_MAX 3
  37          
  38          bit sensorIdCheckRunFlag = 0;                          //ÔËÐÐ±êÖ¾
  39          bit sensorIdCheckOKFlag = 0;                           //ÅÐ¶ÏOK±êÖ¾
  40          bit ioStatusSaveValue = 0;                             // IO¿Ú×´Ì¬±£´æ
>>>>>>> ac9b71b636d5bf0dc7d832531626a13307726cd8
  41          unsigned char saveTotalSensorID[SENSOR_NUM_MAX] = {0}; //µ±Ç°ËùÓÐÉè±¸IDÎ»ÖÃ,Èç¹ûÎªÓÒ²à´«¸ÐÆ÷£¬Ôò×Ô¶¨ÒåÎªÖ÷
             -´«¸ÐÆ÷£¬Ë³Ðò·Ö±ð´ú±í£º×ó£¬×óÖÐ£¬ÓÒÖÐ£¬ÓÒ
  42          unsigned char sensorIdCheckState = 0;                  //ÔËÐÐ×´Ì¬»ú
  43          unsigned int sensorIdCheckTimeCnt = 0;                 //¶¨Ê±Æ÷
  44          unsigned char sensorIdGetCnt = 0;                      // ID »ñÈ¡¼ÆÊý
  45          unsigned char currentSensorID = 0;                     //µ±Ç°´«¸ÐÆ÷Öµ
  46          
  47          unsigned char appTaskState = 0;
  48          unsigned int appTaskTimeCnt = 0;
  49          
  50          unsigned char get_currentSensorID(void)
  51          {
  52   1          return currentSensorID;
  53   1      }
<<<<<<< HEAD
C51 COMPILER V9.54   TASK                                                                  05/17/2022 22:00:16 PAGE 2   

  54          
  55          //ÅÐ¶Ï±ê×¼
  56          //P35Êä³ö¸ßµçÆ½£¬Èç¹ûP34µçÑ¹ÎªµÍµçÆ½£¬¾ÍÊÇ×ó,ÓÒ´«¸ÐÆ÷£»Èç¹ûP34Îª¸ßµçÆ½¾ÍÊÇ×óÖÐ£¬ÓÒÖÐ
  57          //P35Êä³öµÍµçÆ½£¬Èç¹ûP34µçÑ¹ÎªµÍµçÆ½£¬¾ÍÊÇ×ó£¬ÓÒÖÐ´«¸ÐÆ÷£¬Èç¹ûP34Îª¸ßµçÆ½£¬¾ÍÊÇÓÒ£¬×óÖÐ´«¸ÐÆ÷¡£
  58          //Á½´ÎµçÆ½ÏàµÈºãµÍ¾ÍÊÇ×óÖÐ£¬ºã¸ß¾ÍÊÇ×ó£»Á½´ÎµçÆ½²»µÈ£¬µ«ÓëP35µçÆ½ÏàµÈ¾ÍÊÇÓÒÖÐ£¬ÓëP35µçÆ½²»µÈ¾ÍÊÇÓÒ¡£
  59          
  60          void sensorIdAdjustTask(void)
  61          {
  62   1          if (sensorIdCheckRunFlag == 1)
  63   1              return;
  64   1          switch (sensorIdCheckState)
  65   1          {
  66   2          case SensorCheck_0:
  67   2              PWM_OUTPUT = HIGH;
  68   2              sensorIdCheckTimeCnt = Get_SysHalfMsTick(); //Ë¢ÐÂ¼ÆÊ±Æ÷
  69   2              sensorIdCheckState = SensorCheck_1;
  70   2              break;
  71   2          case SensorCheck_1:
  72   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 20) // µÈ´ý20ms
  73   2              {
  74   3                  ioStatusSaveValueOld = SENSOR_ID_CHECK; //¼ÇÂ¼SENSOR_ID_CHECKµçÆ½             
  75   3                  sensorIdCheckState = SensorCheck_2;
  76   3              }
  77   2              break;
  78   2          case SensorCheck_2:
  79   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 50) // µÈ´ý30msºóÔÙ·´×ªµçÆ½£
             -¬±ÜÃâµçÆ½³åÍ»
  80   2              {
  81   3                  PWM_OUTPUT = LOW;
  82   3                  sensorIdCheckState = SensorCheck_3;
  83   3              }
  84   2              break;
  85   2          case SensorCheck_3:                                                      
  86   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 100) // 50ms³¬Ê±ºó¼ÌÐøÍùÏÂ½ø
             -ÐÐ
  87   2              {
  88   3                  ioStatusSaveValueNew = SENSOR_ID_CHECK; //¼ÇÂ¼SENSOR_ID_CHECKµçÆ½
  89   3                  if (SENSOR_ID_CHECK == LOW) 
  90   3                  {
  91   4                      if (ioStatusSaveValueNew == ioStatusSaveValueOld) //Á½´ÎSENSOR_ID_CHECKµçÆ½ÏàµÈºãµÍ
  92   4                      {
  93   5                          currentSensorID = LEFT_MID_SENSOR;
  94   5                      }
  95   4                      else //Á½´ÎµçÆ½²»µÈ£¬µ«ÓëP35µçÆ½ÏàµÈ¾ÍÊÇÓÒÖÐ
  96   4                      {
  97   5                          currentSensorID = RIGHT_MID_SENSOR;
  98   5                      }
  99   4                  }
 100   3                  else
 101   3                  {
 102   4                      if (ioStatusSaveValueNew == ioStatusSaveValueOld) //Á½´ÎSENSOR_ID_CHECKµçÆ½ÏàµÈºã¸ß
 103   4                      {
 104   5                          currentSensorID = LEFT_SENSOR;
 105   5                      }
 106   4                      else //Á½´ÎµçÆ½²»µÈ£¬ÓëP35µçÆ½²»µÈ¾ÍÊÇÓÒ
 107   4                      {
 108   5                          currentSensorID = RIGHT_SENSOR;                   
 109   5                      }
 110   4                  }
 111   3                  sensorIdCheckState = SensorCheck_4; 
 112   3                  UART_config();        
 113   3              }
C51 COMPILER V9.54   TASK                                                                  05/17/2022 22:00:16 PAGE 3   

 114   2              break;
 115   2          case SensorCheck_4: 
 116   2              if(currentSensorID == RIGHT_SENSOR)//Èç¹ûÊÇÓÒ´«¸ÐÆ÷ÐèÒª¸úÆäËû´«¸ÐÆ÷Í¨ÐÅ
 117   2              {
 118   3                  getSensorImfo(RIGHT_MID_SENSOR, CMD_ID);
 119   3                  sensorIdCheckState = SensorCheck_5;
 120   3                  sensorIdCheckTimeCnt = Get_SysHalfMsTick(); //Ë¢ÐÂ¼ÆÊ±Æ÷
 121   3              }
 122   2              else//²»ÊÇÓÒ´«¸ÐÆ÷£¬µÈ´ý½ÓÊÕÊý¾Ý
 123   2              {
 124   3                  sensorIdCheckState = WAIT_REV_CMD;
 125   3              }
 126   2              break;
 127   2          case SensorCheck_5:                                                      //ÅÐ¶ÏÊÇ·ñÊÕµ½ÓÒÖÐÌ½Í·IDÐÅÏ¢
 128   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 50) // 50ms³¬Ê±ºó¼ÌÐøÍùÏÂ½øÐ
             -Ð
 129   2              {
 130   3                  if (analysisSensorImfo())
 131   3                  {
 132   4                      //ÊÕµ½ÓÒÖÐÌ½Í·IDÐÅÏ¢
 133   4                      saveTotalSensorID[2] = 1;
 134   4                      sensorIdGetCnt = 0;
 135   4                      sensorIdCheckState = SensorCheck_6;
 136   4                  }
 137   3                  else
 138   3                  {
 139   4                      sensorIdGetCnt++;
 140   4                      sensorIdCheckState = SensorCheck_4;
 141   4                      if (sensorIdGetCnt >= GET_SENSOR_ID_CNT_MAX)
 142   4                      {
 143   5                          sensorIdGetCnt = 0;
 144   5                          sensorIdCheckState = SensorCheck_6;
 145   5                      }
 146   4                  }
 147   3              }
 148   2              break;
 149   2          case SensorCheck_6:                //·¢ËÍ»ñÈ¡×ó²àÌ½Í·ÐÅÏ¢Ö¸Áî
 150   2              getSensorImfo(LEFT_SENSOR, CMD_ID); //·¢ËÍ»ñÈ¡×ó²àÌ½Í·ÐÅÏ¢Ö¸Áî
 151   2              sensorIdCheckState = SensorCheck_7;
 152   2              sensorIdCheckTimeCnt = Get_SysHalfMsTick(); //Ë¢ÐÂ¼ÆÊ±Æ÷
 153   2              break;
 154   2          case SensorCheck_7:                                                      //ÅÐ¶ÏÊÇ·ñÊÕµ½×ó²àÌ½Í·IDÐÅÏ¢
 155   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 50) // 50ms³¬Ê±ºó¼ÌÐøÍùÏÂ½øÐ
             -Ð
 156   2              {
 157   3                  if (analysisSensorImfo())
 158   3                  {
 159   4                      //ÊÕµ½×ó²àÌ½Í·IDÐÅÏ¢
 160   4                      saveTotalSensorID[0] = 1;
 161   4                      sensorIdGetCnt = 0;
 162   4                      sensorIdCheckState = SensorCheck_8;
 163   4                  }
 164   3                  else
 165   3                  {
 166   4                      sensorIdGetCnt++;
 167   4                      sensorIdCheckState = SensorCheck_6;
 168   4                      if (sensorIdGetCnt >= GET_SENSOR_ID_CNT_MAX)
 169   4                      {
 170   5                          sensorIdGetCnt = 0;
 171   5                          sensorIdCheckState = SensorCheck_8;
 172   5                      }
 173   4                  }
C51 COMPILER V9.54   TASK                                                                  05/17/2022 22:00:16 PAGE 4   

 174   3              }
 175   2              break;
 176   2          case SensorCheck_8:                    //·¢ËÍ»ñÈ¡×óÖÐÌ½Í·ÐÅÏ¢Ö¸Áî
 177   2              getSensorImfo(LEFT_MID_SENSOR, CMD_ID); //·¢ËÍ»ñÈ¡×óÖÐÌ½Í·ÐÅÏ¢Ö¸Áî
 178   2              sensorIdCheckState = SensorCheck_9;
 179   2              sensorIdCheckTimeCnt = Get_SysHalfMsTick(); //Ë¢ÐÂ¼ÆÊ±Æ÷
 180   2              break;
 181   2          case SensorCheck_9:                                                      //ÅÐ¶ÏÊÇ·ñÊÕµ½×óÖÐÌ½Í·IDÐÅÏ¢
 182   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 50) // 50ms³¬Ê±ºó¼ÌÐøÍùÏÂ½øÐ
             -Ð
 183   2              {
 184   3                  if (analysisSensorImfo())
 185   3                  {
 186   4                      //ÊÕµ½×óÖÐÌ½Í·IDÐÅÏ¢
 187   4                      saveTotalSensorID[1] = 1;
 188   4                      sensorIdGetCnt = 0;
 189   4                      sensorIdCheckState = WAIT_STATE;
 190   4                  }
 191   3                  else
 192   3                  {
 193   4                      sensorIdGetCnt++;
 194   4                      sensorIdCheckState = SensorCheck_8;
 195   4                      if (sensorIdGetCnt >= GET_SENSOR_ID_CNT_MAX)
 196   4                      {
 197   5                          sensorIdGetCnt = 0;
 198   5                          sensorIdCheckState = WAIT_STATE;
 199   5                      }
 200   4                  }
 201   3              }
 202   2              break;
 203   2          case WAIT_REV_CMD:                                                             //½øÈëÕâÀï£¬±ØÈ»²»ÊÇÓÒ´
             -«¸ÐÆ÷
 204   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 600) // 600ms³¬Ê±ºó¼ÌÐøÍùÏÂ½
             -øÐÐ
 205   2              {
 206   3                  sensorIdCheckState = WAIT_STATE;
 207   3              }
 208   2              else
 209   2              {
 210   3                  if (analysisSensorImfo()) //ÊÇ·ñÊÕµ½»ñÈ¡Î»ÖÃÐÅÏ¢Ö¸Áî
 211   3                  {
 212   4                      //½âÎö»Ø¸´Êý¾Ý
 213   4                      sensorIdCheckState = WAIT_STATE;
 214   4                  }
 215   3              }
 216   2              break;
 217   2          case WAIT_STATE: // ÅÐ¶Ï×ó²àÌ½Í·Î»ÖÃ
 218   2              sensorIdCheckState = 0;
 219   2              sensorIdCheckRunFlag = 1; //Ì½Í·Î»ÖÃÊ¶±ðÍê³É
 220   2              break;
 221   2          }
 222   1      }
 223          
 224          void AppTask(void)
 225          {
 226   1          if (sensorIdCheckRunFlag == 0)
 227   1              return;
 228   1          switch (appTaskState)
 229   1          {
 230   2          case 0: //·¢ËÍPWM 150ms ÓÃÀ´È·ÈÏÎ»ÖÃÐÅºÅ
 231   2              StartBeepAlarm(150, 0);
 232   2              appTaskTimeCnt = Get_SysHalfMsTick();
C51 COMPILER V9.54   TASK                                                                  05/17/2022 22:00:16 PAGE 5   

 233   2              appTaskState = 1;
 234   2              break;
 235   2          case 1: // Sensor ID»áÊÕµ½×Ô¼º·¢µÄÐÅºÅ
 236   2              if (SENSOR_ID_CHECK == 0)
 237   2              {
 238   3                  VirtualCOM_StringSend("recv ID!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 239   3                  appTaskState = 2;
 240   3              }
 241   2              else if (get_time_escape_sec(Get_SysHalfMsTick(), appTaskTimeCnt) >= 20) // 10ms³¬Ê±ºó¼ÌÐøÍùÏÂ½øÐÐ
 242   2              {
 243   3                  VirtualCOM_StringSend("recv ID timeout!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 244   3                  appTaskState = 2;
 245   3              }
 246   2              break;
 247   2          case 2: //¿ª»úÌ½Í·×Ô¼ì
 248   2              Start_sendOncePlusTask();
 249   2              appTaskState = 3;
 250   2              VirtualCOM_StringSend("sensor self check!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 251   2              break;
 252   2          case 3: //»ñÈ¡Ì½Í·×Ô¼ì½á¹û
 253   2              if (Get_SendOncePlusTaskFlag() == 0)
 254   2              {
 255   3                  if (Get_sensorOkFlag())
 256   3                  {
 257   4                      VirtualCOM_StringSend("sensor is ok!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 258   4                      appTaskState = 4;                           //¼ì²âµ½Ì½Í·
 259   4                  }
 260   3                  else
 261   3                  {
 262   4                      VirtualCOM_StringSend("No sensor!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 263   4                      appTaskState = 0;                        //ÎÞÌ½Í·´ÓÍ·¿ªÊ¼
 264   4                  }
 265   3      //            uartSendPackage(SELF_CHECK);
 266   3              }
 267   2              break;
 268   2          case 4: //¿ªÊ¼²â¾à½á¹û
 269   2              appTaskTimeCnt = Get_SysHalfMsTick();
 270   2              Start_sendOncePlusTask();
 271   2              appTaskState = 5;
 272   2              break;
 273   2          case 5: //ÅÐ¶ÏÊÇ·ñÓÐÕÏ°­Îï
 274   2              if (Get_SendOncePlusTaskFlag() == 0)
 275   2              {
 276   3                  if (Get_obstaclesExistenceFlag()) //ÓÐÕÏ°­Îï
 277   3                  {
 278   4                      if (get_time_escape_sec(Get_SysHalfMsTick(), appTaskTimeCnt) >= 100) // 50ms²âÊÔÒ»´Î
 279   4                      {
 280   5                          VirtualCOM_StringSend("obstacle!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 281   5                          appTaskState = 4;
 282   5      //                    uartSendPackage(NOM_WORK);
 283   5                      }
 284   4                  }
 285   3                  else //Ã»ÓÐÕÏ°­Îï
 286   3                  {
 287   4                      if (get_time_escape_sec(Get_SysHalfMsTick(), appTaskTimeCnt) >= 400) // 200ms²âÊÔÒ»´Î
 288   4                      {
 289   5                          //»ñÈ¡²âÊÔ¾àÀë
 290   5                          VirtualCOM_StringSend("No obstacles!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 291   5                          appTaskState = 4;
 292   5      //                    uartSendPackage(NOM_WORK);
 293   5                      }
 294   4                  }
C51 COMPILER V9.54   TASK                                                                  05/17/2022 22:00:16 PAGE 6   

 295   3              }
 296   2              break;
 297   2          default:
 298   2              break;
 299   2          }
 300   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    672    ----
=======
C51 COMPILER V9.54   TASK                                                                  04/23/2022 08:59:35 PAGE 2   

  54          
  55          void sensorIdAdjustTask(void)
  56          {
  57   1          if (sensorIdCheckRunFlag == 1)
  58   1              return;
  59   1          switch (sensorIdCheckState)
  60   1          {
  61   2          case RightSensorCheck_0:
  62   2              PWM_OUTPUT = LOW;
  63   2              sensorIdCheckTimeCnt = Get_SysHalfMsTick(); //Ë¢ÐÂ¼ÆÊ±Æ÷
  64   2              sensorIdCheckState = RightSensorCheck_1;
  65   2              break;
  66   2          case RightSensorCheck_1:
  67   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 20) // µÈ´ý20ms
  68   2              {
  69   3                  if (SENSOR_ID_CHECK == LOW) //´ËÊ±×ó£¬ÓÒÖÐ£¬ÓÒ¶¼Âú×ãÒªÇó,Ö»ÓÐ×óÖÐ²»Âú×ãÒªÇó
  70   3                  {
  71   4                      ioStatusSaveValue = SENSOR_ID_CHECK; //¼ÇÂ¼SENSOR_ID_CHECKµçÆ½
  72   4                      sensorIdCheckState = RightSensorCheck_2;
  73   4                  }
  74   3                  else
  75   3                  {
  76   4                      currentSensorID = LEFT_MID_SENSOR;
  77   4                      sensorIdCheckState = WAIT_REV_CMD; //ºóÐøÅÐ¶Á×óÖÐÊÇ·ñ´æÔÚ
  78   4                  }
  79   3              }
  80   2              break;
  81   2          case RightSensorCheck_2:
  82   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 50) // µÈ´ý30msºóÔÙ·´×ªµçÆ½£
             -¬±ÜÃâµçÆ½³åÍ»
  83   2              {
  84   3                  PWM_OUTPUT = HIGH;
  85   3                  sensorIdCheckState = RightSensorCheck_3;
  86   3              }
  87   2              break;
  88   2          case RightSensorCheck_3:                                                       // ÅÐ¶ÏÓÒ²àÌ½Í·Î»ÖÃ    
             -                                                  // ÅÐ¶Ï×óÖÐÌ½Í·Î»ÖÃ
  89   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 100) // 50ms³¬Ê±ºó¼ÌÐøÍùÏÂ½ø
             -ÐÐ
  90   2              {
  91   3                  if (SENSOR_ID_CHECK == HIGH) //´ËÊ±ÓÒÖÐ£¬ÓÒÂú×ãÒªÇó£¬Ö»ÓÐ×ó²»Âú×ãÒªÇó
  92   3                  {
  93   4                      if (SENSOR_ID_CHECK == ioStatusSaveValue) //Á½´ÎSENSOR_ID_CHECKµçÆ½ÏàµÈ¾ÍÊÇÓÒ
  94   4                      {
  95   5                          currentSensorID = RIGHT_SENSOR;
  96   5                          sensorIdCheckState = RightSensorCheck_4; //ÓÒÒ»¶¨´æÔÚ£¬²»ÓÃÅÐ¶Ï
  97   5                      }
  98   4                      else //²»ÏàµÈ¾ÍÊÇÓÒÖÐ
  99   4                      {
 100   5                          currentSensorID = RIGHT_MID_SENSOR;
 101   5                          sensorIdCheckState = WAIT_REV_CMD; //ºóÐøÅÐ¶ÁÓÒÖÐÊÇ·ñ´æÔÚ
 102   5                      }
 103   4                  }
 104   3                  else
 105   3                  {
 106   4                      currentSensorID = LEFT_SENSOR;
 107   4                      sensorIdCheckState = WAIT_REV_CMD; //ºóÐøÅÐ¶Á×óÊÇ·ñ´æÔÚ
 108   4                  }
 109   3              }
 110   2              break;
 111   2          case RightSensorCheck_4: //½øÈë´Ë×´Ì¬»ú£¬±ØÈ»ÎªÓÒ²àÌ½Í·£¬·¢ËÍ»ñÈ¡ÓÒÖÐÌ½Í·ÐÅÏ¢Ö¸Áî
 112   2              getSensorImfo(RIGHT_MID_SENSOR, CMD_ID);
C51 COMPILER V9.54   TASK                                                                  04/23/2022 08:59:35 PAGE 3   

 113   2              sensorIdCheckState = RightSensorCheck_5;
 114   2              sensorIdCheckTimeCnt = Get_SysHalfMsTick(); //Ë¢ÐÂ¼ÆÊ±Æ÷
 115   2              break;
 116   2          case RightSensorCheck_5:                                                      //ÅÐ¶ÏÊÇ·ñÊÕµ½ÓÒÖÐÌ½Í·ID
             -ÐÅÏ¢
 117   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 50) // 50ms³¬Ê±ºó¼ÌÐøÍùÏÂ½øÐ
             -Ð
 118   2              {
 119   3                  if (analysisSensorImfo())
 120   3                  {
 121   4                      //ÊÕµ½ÓÒÖÐÌ½Í·IDÐÅÏ¢
 122   4                      saveTotalSensorID[2] = 1;
 123   4                      sensorIdGetCnt = 0;
 124   4                      sensorIdCheckState = RightSensorCheck_6;
 125   4                  }
 126   3                  else
 127   3                  {
 128   4                      sensorIdGetCnt++;
 129   4                      sensorIdCheckState = RightSensorCheck_4;
 130   4                      if (sensorIdGetCnt >= GET_SENSOR_ID_CNT_MAX)
 131   4                      {
 132   5                          sensorIdGetCnt = 0;
 133   5                          sensorIdCheckState = RightSensorCheck_6;
 134   5                      }
 135   4                  }
 136   3              }
 137   2              break;
 138   2          case RightSensorCheck_6:                //·¢ËÍ»ñÈ¡×ó²àÌ½Í·ÐÅÏ¢Ö¸Áî
 139   2              getSensorImfo(LEFT_SENSOR, CMD_ID); //·¢ËÍ»ñÈ¡×ó²àÌ½Í·ÐÅÏ¢Ö¸Áî
 140   2              sensorIdCheckState = RightSensorCheck_7;
 141   2              sensorIdCheckTimeCnt = Get_SysHalfMsTick(); //Ë¢ÐÂ¼ÆÊ±Æ÷
 142   2              break;
 143   2          case RightSensorCheck_7:                                                      //ÅÐ¶ÏÊÇ·ñÊÕµ½×ó²àÌ½Í·ID
             -ÐÅÏ¢
 144   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 50) // 50ms³¬Ê±ºó¼ÌÐøÍùÏÂ½øÐ
             -Ð
 145   2              {
 146   3                  if (analysisSensorImfo())
 147   3                  {
 148   4                      //ÊÕµ½×ó²àÌ½Í·IDÐÅÏ¢
 149   4                      saveTotalSensorID[0] = 1;
 150   4                      sensorIdGetCnt = 0;
 151   4                      sensorIdCheckState = RightSensorCheck_8;
 152   4                  }
 153   3                  else
 154   3                  {
 155   4                      sensorIdGetCnt++;
 156   4                      sensorIdCheckState = RightSensorCheck_6;
 157   4                      if (sensorIdGetCnt >= GET_SENSOR_ID_CNT_MAX)
 158   4                      {
 159   5                          sensorIdGetCnt = 0;
 160   5                          sensorIdCheckState = RightSensorCheck_8;
 161   5                      }
 162   4                  }
 163   3              }
 164   2              break;
 165   2          case RightSensorCheck_8:                    //·¢ËÍ»ñÈ¡×óÖÐÌ½Í·ÐÅÏ¢Ö¸Áî
 166   2              getSensorImfo(LEFT_MID_SENSOR, CMD_ID); //·¢ËÍ»ñÈ¡×óÖÐÌ½Í·ÐÅÏ¢Ö¸Áî
 167   2              sensorIdCheckState = RightSensorCheck_9;
 168   2              sensorIdCheckTimeCnt = Get_SysHalfMsTick(); //Ë¢ÐÂ¼ÆÊ±Æ÷
 169   2              break;
 170   2          case RightSensorCheck_9:                                                      //ÅÐ¶ÏÊÇ·ñÊÕµ½×óÖÐÌ½Í·ID
C51 COMPILER V9.54   TASK                                                                  04/23/2022 08:59:35 PAGE 4   

             -ÐÅÏ¢
 171   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 50) // 50ms³¬Ê±ºó¼ÌÐøÍùÏÂ½øÐ
             -Ð
 172   2              {
 173   3                  if (analysisSensorImfo())
 174   3                  {
 175   4                      //ÊÕµ½×óÖÐÌ½Í·IDÐÅÏ¢
 176   4                      saveTotalSensorID[1] = 1;
 177   4                      sensorIdGetCnt = 0;
 178   4                      sensorIdCheckState = WAIT_STATE;
 179   4                  }
 180   3                  else
 181   3                  {
 182   4                      sensorIdGetCnt++;
 183   4                      sensorIdCheckState = RightSensorCheck_8;
 184   4                      if (sensorIdGetCnt >= GET_SENSOR_ID_CNT_MAX)
 185   4                      {
 186   5                          sensorIdGetCnt = 0;
 187   5                          sensorIdCheckState = WAIT_STATE;
 188   5                      }
 189   4                  }
 190   3              }
 191   2              break;
 192   2          case WAIT_REV_CMD:                                                             //½øÈëÕâÀï£¬±ØÈ»²»ÊÇÓÒ´
             -«¸ÐÆ÷
 193   2              if (get_time_escape_sec(Get_SysHalfMsTick(), sensorIdCheckTimeCnt) >= 600) // 600ms³¬Ê±ºó¼ÌÐøÍùÏÂ½
             -øÐÐ
 194   2              {
 195   3                  sensorIdCheckState = WAIT_STATE;
 196   3              }
 197   2              else
 198   2              {
 199   3                  if (analysisSensorImfo()) //ÊÇ·ñÊÕµ½»ñÈ¡Î»ÖÃÐÅÏ¢Ö¸Áî
 200   3                  {
 201   4                      //½âÎö»Ø¸´Êý¾Ý
 202   4                      sensorIdCheckState = WAIT_STATE;
 203   4                  }
 204   3              }
 205   2              break;
 206   2          case WAIT_STATE: // ÅÐ¶Ï×ó²àÌ½Í·Î»ÖÃ
 207   2              sensorIdCheckState = 0;
 208   2              sensorIdCheckRunFlag = 1; //Ì½Í·Î»ÖÃÊ¶±ðÍê³É
 209   2              break;
 210   2          }
 211   1      }
 212          
 213          void AppTask(void)
 214          {
 215   1          if (sensorIdCheckRunFlag == 0)
 216   1              return;
 217   1          switch (appTaskState)
 218   1          {
 219   2          case 0: //·¢ËÍPWM 150ms ÓÃÀ´È·ÈÏÎ»ÖÃÐÅºÅ
 220   2              StartBeepAlarm(150,0);
 221   2              appTaskTimeCnt = Get_SysHalfMsTick();
 222   2              appTaskState = 1;
 223   2              break;
 224   2          case 1: // Sensor ID»áÊÕµ½×Ô¼º·¢µÄÐÅºÅ
 225   2              if (P34 == 0)
 226   2              {
 227   3                  VirtualCOM_StringSend("recv ID!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 228   3                  appTaskState = 2;
C51 COMPILER V9.54   TASK                                                                  04/23/2022 08:59:35 PAGE 5   

 229   3              }
 230   2              else if (get_time_escape_sec(Get_SysHalfMsTick(), appTaskTimeCnt) >= 20) // 10ms³¬Ê±ºó¼ÌÐøÍùÏÂ½øÐÐ
 231   2              {
 232   3                  VirtualCOM_StringSend("recv ID timeout!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 233   3                  appTaskState = 2;
 234   3              }
 235   2              break;
 236   2          case 2: //¿ª»úÌ½Í·×Ô¼ì
 237   2              Start_sendOncePlusTask();
 238   2              appTaskState = 3;
 239   2              VirtualCOM_StringSend("sensor self check!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 240   2              break;
 241   2          case 3: //»ñÈ¡Ì½Í·×Ô¼ì½á¹û
 242   2              if (Get_SendOncePlusTaskFlag() == 0)
 243   2              {
 244   3                  if (Get_sensorOkFlag())
 245   3                  {
 246   4                      VirtualCOM_StringSend("sensor is ok!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 247   4                      appTaskState = 4;                           //¼ì²âµ½Ì½Í·
 248   4                  }
 249   3                  else
 250   3                  {
 251   4                      VirtualCOM_StringSend("No sensor!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 252   4                      appTaskState = 0;                        //ÎÞÌ½Í·´ÓÍ·¿ªÊ¼
 253   4                  }
 254   3                  uartSendPackage(SELF_CHECK);
 255   3              }
 256   2              break;
 257   2          case 4: //¿ªÊ¼²â¾à½á¹û
 258   2              appTaskTimeCnt = Get_SysHalfMsTick();
 259   2              Start_sendOncePlusTask();
 260   2              appTaskState = 5;
 261   2              break;
 262   2          case 5: //ÅÐ¶ÏÊÇ·ñÓÐÕÏ°­Îï
 263   2              if (Get_SendOncePlusTaskFlag() == 0)
 264   2              {
 265   3                  if (Get_obstaclesExistenceFlag()) //ÓÐÕÏ°­Îï
 266   3                  {
 267   4                      if (get_time_escape_sec(Get_SysHalfMsTick(), appTaskTimeCnt) >= 100) // 50ms²âÊÔÒ»´Î
 268   4                      {
 269   5                          VirtualCOM_StringSend("obstacle!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 270   5                          appTaskState = 4;
 271   5                          uartSendPackage(NOM_WORK);
 272   5                      }
 273   4                  }
 274   3                  else //Ã»ÓÐÕÏ°­Îï
 275   3                  {
 276   4                      if (get_time_escape_sec(Get_SysHalfMsTick(), appTaskTimeCnt) >= 400) // 200ms²âÊÔÒ»´Î
 277   4                      {
 278   5                          //»ñÈ¡²âÊÔ¾àÀë
 279   5                          VirtualCOM_StringSend("No obstacles!\r\n"); // UART1·¢ËÍÒ»¸ö×Ö·û´®
 280   5                          appTaskState = 4;
 281   5                          uartSendPackage(NOM_WORK);
 282   5                      }
 283   4                  }
 284   3              }
 285   2              break;
 286   2          default:
 287   2              break;
 288   2          }
 289   1      }

C51 COMPILER V9.54   TASK                                                                  04/23/2022 08:59:35 PAGE 6   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    682    ----
>>>>>>> ac9b71b636d5bf0dc7d832531626a13307726cd8
   CONSTANT SIZE    =    108    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12    ----
   IDATA SIZE       =   ----    ----
<<<<<<< HEAD
   BIT SIZE         =      4    ----
=======
   BIT SIZE         =      3    ----
>>>>>>> ac9b71b636d5bf0dc7d832531626a13307726cd8
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
