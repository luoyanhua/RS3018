<<<<<<< HEAD
C51 COMPILER V9.54   UART                                                                  05/17/2022 22:00:16 PAGE 1   
=======
C51 COMPILER V9.54   UART                                                                  04/23/2022 08:59:35 PAGE 1   
>>>>>>> ac9b71b636d5bf0dc7d832531626a13307726cd8


C51 COMPILER V9.54, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\list\UART.obj
COMPILER INVOKED BY: D:\keil\keil_C51\C51\BIN\C51.EXE UART.C OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\list\UA
                    -RT.lst) OBJECT(.\list\UART.obj)

line level    source

   1          /*---------------------------------------------------------------------*/
   2          /* --- STC MCU Limited ------------------------------------------------*/
   3          /* --- STC 1T Series MCU Demo Programme -------------------------------*/
   4          /* --- Mobile: (86)13922805190 ----------------------------------------*/
   5          /* --- Fax: 86-0513-55012956,55012947,55012969 ------------------------*/
   6          /* --- Tel: 86-0513-55012928,55012929,55012966 ------------------------*/
   7          /* --- Web: www.STCMCU.com --------------------------------------------*/
   8          /* --- Web: www.STCMCUDATA.com  ---------------------------------------*/
   9          /* --- QQ:  800003751 -------------------------------------------------*/
  10          /* »Áπ˚“™‘⁄≥Ã–Ú÷– π”√¥À¥˙¬Î,«Î‘⁄≥Ã–Ú÷–◊¢√˜ π”√¡ÀSTCµƒ◊ ¡œº∞≥Ã–Ú            */
  11          /*---------------------------------------------------------------------*/
  12          
  13          #include "Task.h"
  14          #include "timer.h"
  15          #include "Beep.h"
  16          #include "Task.h"
  17          #include "Sensor.h"
  18          #include "delay.h"
  19          #include "UART.h"
  20          #include <string.h>
  21          
  22          unsigned char xdata txBuf[14];
  23          unsigned char xdata rxbuf[COM_RX2_Lenth];
  24          unsigned char rxlen = 0;
  25          
  26          COMx_Define COM2;
  27          u8 xdata TX2_Buffer[COM_TX2_Lenth]; //∑¢ÀÕª∫≥Â
  28          u8 xdata RX2_Buffer[COM_RX2_Lenth]; //Ω” ’ª∫≥Â
  29          
  30          u8 UART_Configuration(u8 UARTx, COMx_InitDefine *COMx)
  31          {
  32   1              u8 i;
  33   1              u32 j;
  34   1      
  35   1              if (UARTx == UART2)
  36   1              {
  37   2                      COM2.id = 2;
  38   2                      COM2.TX_read = 0;
  39   2                      COM2.TX_write = 0;
  40   2                      COM2.B_TX_busy = 0;
  41   2                      COM2.RX_Cnt = 0;
  42   2                      COM2.RX_TimeOut = 0;
  43   2                      COM2.B_RX_OK = 0;
  44   2                      for (i = 0; i < COM_TX2_Lenth; i++)
  45   2                              TX2_Buffer[i] = 0;
  46   2                      for (i = 0; i < COM_RX2_Lenth; i++)
  47   2                              RX2_Buffer[i] = 0;
  48   2      
  49   2                      if ((COMx->UART_Mode == UART_9bit_BRTx) || (COMx->UART_Mode == UART_8bit_BRTx)) //ø…±‰≤®Ãÿ¬ 
  50   2                      {
  51   3                              if (COMx->UART_Priority > Priority_3)
  52   3                                      return 2;                                                //¥ÌŒÛ
  53   3                              UART2_Priority(COMx->UART_Priority); //÷∏∂®÷–∂œ”≈œ»º∂(µÕµΩ∏ﬂ) Priority_0,Priority_1,Priority_2,Priority
             -_3
<<<<<<< HEAD
C51 COMPILER V9.54   UART                                                                  05/17/2022 22:00:16 PAGE 2   
=======
C51 COMPILER V9.54   UART                                                                  04/23/2022 08:59:35 PAGE 2   
>>>>>>> ac9b71b636d5bf0dc7d832531626a13307726cd8

  54   3                              if (COMx->UART_Mode == UART_9bit_BRTx)
  55   3                                      S2CON |= (1 << 7); // 9bit
  56   3                              else
  57   3                                      S2CON &= ~(1 << 7);                                        // 8bit
  58   3                              j = (MAIN_Fosc / 4) / COMx->UART_BaudRate; //∞¥1Tº∆À„
  59   3                              if (j >= 65536UL)
  60   3                                      return 2; //¥ÌŒÛ
  61   3                              j = 65536UL - j;
  62   3                              AUXR &= ~(1 << 4); // Timer stop
  63   3                              AUXR &= ~(1 << 3); // Timer2 set As Timer
  64   3                              AUXR |= (1 << 2);  // Timer2 set as 1T mode
  65   3                              TH2 = (u8)(j >> 8);
  66   3                              TL2 = (u8)j;
  67   3                              IE2 &= ~(1 << 2); //Ω˚÷π÷–∂œ
  68   3                              AUXR |= (1 << 4); // Timer run enable
  69   3                      }
  70   2                      else
  71   2                              return 2; //ƒ£ Ω¥ÌŒÛ
  72   2                      if (COMx->UART_Interrupt == ENABLE)
  73   2                              IE2 |= 1; //‘ –Ì÷–∂œ
  74   2                      else
  75   2                              IE2 &= ~1; //Ω˚÷π÷–∂œ
  76   2                      if (COMx->UART_RxEnable == ENABLE)
  77   2                              S2CON |= (1 << 4); //‘ –ÌΩ” ’
  78   2                      else
  79   2                              S2CON &= ~(1 << 4);                                                      //Ω˚÷πΩ” ’
  80   2                      P_SW2 = (P_SW2 & ~1) | (COMx->UART_P_SW & 0x01); //«–ªªIO
  81   2                      return 0;
  82   2              }
  83   1              return 2; //¥ÌŒÛ
  84   1      }
  85          
  86          /*********************************************************/
  87          
  88          void UART2_int(void) interrupt UART2_VECTOR
  89          {
  90   1              if (RI2)
  91   1              {
  92   2                      CLR_RI2();
  93   2                      if (COM2.B_RX_OK == 0)
  94   2                      {
  95   3                              if (COM2.RX_Cnt >= COM_RX2_Lenth)
  96   3                                      COM2.RX_Cnt = 0;
  97   3                              RX2_Buffer[COM2.RX_Cnt++] = S2BUF;
  98   3                              COM2.RX_TimeOut = TimeOutSet2;
  99   3                      }
 100   2              }
 101   1      
 102   1              if (TI2)
 103   1              {
 104   2                      CLR_TI2();
<<<<<<< HEAD
 105   2                      COM2.B_TX_busy = 0;
 106   2              }
 107   1      }
 108          
 109          /********************* UART2 ∫Ø ˝ ************************/
 110          void TX2_write2buff(u8 dat) //–¥»Î∑¢ÀÕª∫≥Â£¨÷∏’Î+1
 111          {
 112   1              
 113   1              while(COM2.B_TX_busy){};
 114   1              COM2.B_TX_busy = 1; //±Í÷æ√¶    
 115   1              S2BUF = dat; //◊∞∑¢ÀÕª∫≥Â
C51 COMPILER V9.54   UART                                                                  05/17/2022 22:00:16 PAGE 3   

 116   1              CLR_TI2();
 117   1      }
 118          
 119          void VirtualCOM_StringSend(unsigned char *str)
 120          {
 121   1      
 122   1      }
*** WARNING C280 IN LINE 119 OF UART.C: 'str': unreferenced local variable
 123          
 124          /***************  ¥Æø⁄≥ı ºªØ∫Ø ˝ *****************/
 125          void UART_config(void)
 126          {
 127   1              COMx_InitDefine COMx_InitStructure;                              //Ω·ππ∂®“Â
 128   1              COMx_InitStructure.UART_Mode = UART_8bit_BRTx;   //ƒ£ Ω,   UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9
             -bit_BRTx
 129   1                                                                                                               //     COMx_InitStructure.UART_BRT_Use   = BRT_Timer2;                 //—°‘Ò≤®Ãÿ¬ ∑¢…˙∆˜, BRT_Timer2 (◊¢“‚: ¥
             -Æø⁄2πÃ∂® π”√BRT_Timer2, À˘“‘≤ª”√—°‘Ò)
 130   1              COMx_InitStructure.UART_BaudRate = 115200ul;             //≤®Ãÿ¬ ,     110 ~ 115200
 131   1              COMx_InitStructure.UART_RxEnable = ENABLE;               //Ω” ’‘ –Ì,   ENABLEªÚDISABLE
 132   1              COMx_InitStructure.UART_Interrupt = ENABLE;              //÷–∂œ‘ –Ì,   ENABLEªÚDISABLE
 133   1              COMx_InitStructure.UART_Priority = Priority_0;   //÷∏∂®÷–∂œ”≈œ»º∂(µÕµΩ∏ﬂ) Priority_0,Priority_1,Priority_2
             -,Priority_3
 134   1              COMx_InitStructure.UART_P_SW = UART2_SW_P10_P11; //«–ªª∂Àø⁄,   UART2_SW_P10_P11,UART2_SW_P46_P47
 135   1              UART_Configuration(UART2, &COMx_InitStructure);  //≥ı ºªØ¥Æø⁄2 UART1,UART2,UART3,UART4
 136   1      
 137   1              UART_CHG_IO = UART_RX_EN;
 138   1      }
 139          
 140          //«Â≥˝Ω” ’ª∫¥Ê
 141          void clrRX2_Buffer(void)
 142          {
 143   1              COM2.RX_Cnt = 0;
=======
 105   2                      if (COM2.TX_read != COM2.TX_write)
 106   2                      {
 107   3                              S2BUF = TX2_Buffer[COM2.TX_read];
 108   3                              if (++COM2.TX_read >= COM_TX2_Lenth)
 109   3                                      COM2.TX_read = 0;
 110   3                      }
 111   2                      else
 112   2                              COM2.B_TX_busy = 0;
 113   2              }
 114   1      }
 115          
C51 COMPILER V9.54   UART                                                                  04/23/2022 08:59:35 PAGE 3   

 116          /********************* UART2 ∫Ø ˝ ************************/
 117          void TX2_write2buff(u8 dat) //–¥»Î∑¢ÀÕª∫≥Â£¨÷∏’Î+1
 118          {
 119   1              TX2_Buffer[COM2.TX_write] = dat; //◊∞∑¢ÀÕª∫≥Â
 120   1              if (++COM2.TX_write >= COM_TX2_Lenth)
 121   1                      COM2.TX_write = 0;
 122   1      
 123   1              if (COM2.B_TX_busy == 0) //ø’œ–
 124   1              {
 125   2                      COM2.B_TX_busy = 1; //±Í÷æ√¶
 126   2                      SET_TI2();                      //¥•∑¢∑¢ÀÕ÷–∂œ
 127   2              }
 128   1      }
 129          
 130          void VirtualCOM_StringSend(unsigned char *str)
 131          {
 132   1              //    while (*str != 0)
 133   1              //    {
 134   1              //        TX2_write2buff(*str);
 135   1              //        str++;
 136   1              //    }
 137   1      }
*** WARNING C280 IN LINE 130 OF UART.C: 'str': unreferenced local variable
 138          
 139          //«Â≥˝Ω” ’ª∫¥Ê
 140          void clrRX2_Buffer(void)
 141          {
 142   1              COM2.RX_Cnt = 0;
 143   1              COM2.RX_TimeOut = 0;
>>>>>>> ac9b71b636d5bf0dc7d832531626a13307726cd8
 144   1              COM2.B_RX_OK = 0;
 145   1              memset(RX2_Buffer, 0, COM_TX2_Lenth);
 146   1      }
 147          
 148          //ªÒ»°Ω” ’µΩµƒ ˝æ› 0:Œ¥ ’µΩ”––ß ˝æ›
 149          unsigned char getRxBuf(void)
 150          {
 151   1              rxlen = COM2.RX_Cnt;
 152   1              if (rxlen == 4 || rxlen == 5) //ƒø«∞÷ª”–¡Ω÷÷–≠“È
 153   1              {
 154   2                      memcpy(rxbuf, RX2_Buffer, rxlen);
 155   2                      return rxlen;
 156   2              }
 157   1              else
 158   1                      return 0;
 159   1      }
 160          
 161          void uartSendBuf(unsigned char *buf, unsigned char len)
 162          {
 163   1              unsigned char i = 0;
<<<<<<< HEAD
 164   1              clrRX2_Buffer();
 165   1              UART_CHG_IO = UART_TX_EN;
 166   1              _nop_();
 167   1              _nop_();
 168   1              _nop_();
 169   1              _nop_();        
 170   1              for (i = 0; i < len; i++)
 171   1              {
 172   2                      TX2_write2buff(buf[i]);
 173   2              }
C51 COMPILER V9.54   UART                                                                  05/17/2022 22:00:16 PAGE 4   

 174   1              while(COM2.B_TX_busy){};
 175   1              _nop_();
 176   1              _nop_();
 177   1              _nop_();
 178   1              _nop_();        
 179   1              UART_CHG_IO = UART_RX_EN;
 180   1      }
 181          
 182          void sensorReplyPackage(unsigned char ch, unsigned char cmd)
 183          {
 184   1              unsigned char temp_txLen = 0;
 185   1              if(cmd == CMD_ID)
 186   1              {
 187   2                      txBuf[0] = 0xBB;
 188   2                      txBuf[1] = cmd;
 189   2                      txBuf[2] = ch;
 190   2                      txBuf[3] = 0xBF;
 191   2                      temp_txLen = 4;
 192   2              }
 193   1              else
 194   1              {
 195   2                      txBuf[0] = 0xBB;
 196   2                      txBuf[1] = cmd;
 197   2                      txBuf[2] = ch;
 198   2                      txBuf[3] = Get_meterDistance()/10;
 199   2                      txBuf[4] = 0xBF;        
 200   2                      temp_txLen = 5; 
 201   2              }
 202   1              uartSendBuf(txBuf,temp_txLen);
 203   1      }
 204          
 205          unsigned char saveTotalSensorDistance[SENSOR_NUM_MAX] = {0}; //À≥–Ú∑÷±¥˙±Ì£∫◊Û£¨◊Û÷–£¨”“÷–£¨”“
 206          
 207          // cmd 0:”“¥´∏–∆˜—≠ª∑ªÒ»°∆‰À˚¥´∏–∆˜Œª÷√–≈œ¢ 1:”“¥´∏–∆˜—≠ª∑ªÒ»°∆‰À˚¥´∏–∆˜æ‡¿Î–≈œ¢
 208          // ch ∏˘æ›∫Í∂®“Â¿¥
 209          void getSensorImfo(unsigned char ch, unsigned char cmd)
 210          {
 211   1              txBuf[0] = 0xBB;
 212   1              txBuf[1] = cmd;
 213   1              txBuf[2] = ch;
 214   1              txBuf[3] = 0xBF;
 215   1              uartSendBuf(txBuf, 4);
 216   1      }
 217          
 218          //Ω” ’ ˝æ›Ω‚Œˆ∫Ø ˝
 219          // buf:Ω” ’ ˝æ›÷∏’Î
 220          // len:Ω” ’ ˝æ›≥§∂»
 221          //∏Ò Ω£∫BB + cmd + ch + distance(BYTE) + BF
 222          unsigned char analysisSensorImfo(void)
 223          {
 224   1              unsigned char result = 0;
 225   1              if (get_currentSensorID() == RIGHT_SENSOR)
 226   1              {
 227   2                      if (rxbuf[1] == CMD_ID)
 228   2                      {
 229   3                              if (rxbuf[2] == LEFT_SENSOR)
 230   3                              {
 231   4                                      result = 1;//¥´∏–∆˜¥Ê‘⁄
 232   4                              }
 233   3                              else if (rxbuf[2] == LEFT_MID_SENSOR)
 234   3                              {
 235   4                                      result = 1;//¥´∏–∆˜¥Ê‘⁄
C51 COMPILER V9.54   UART                                                                  05/17/2022 22:00:16 PAGE 5   

 236   4                              }
 237   3                              else if (rxbuf[2] == RIGHT_MID_SENSOR)
 238   3                              {
 239   4                                      result = 1;//¥´∏–∆˜¥Ê‘⁄
 240   4                              }
 241   3                      }
 242   2                      else
 243   2                      {
 244   3                              if (rxbuf[2] == LEFT_SENSOR)
 245   3                              {
 246   4                                      saveTotalSensorDistance[0] = rxbuf[3] ;
 247   4                                      result = 1;//Ω‚Œˆæ‡¿Î
 248   4                              }
 249   3                              else if (rxbuf[2] == LEFT_MID_SENSOR)
 250   3                              {
 251   4                                      saveTotalSensorDistance[1] = rxbuf[3] ;
 252   4                                      result = 1;//Ω‚Œˆæ‡¿Î
 253   4                              }
 254   3                              else if (rxbuf[2] == RIGHT_MID_SENSOR)
 255   3                              {
 256   4                                      saveTotalSensorDistance[2] = rxbuf[3] ;
 257   4                                      result = 1;//Ω‚Œˆæ‡¿Î
 258   4                              }
 259   3                      }
 260   2              }
 261   1              else
 262   1              {
 263   2                      if (rxbuf[1] == CMD_ID)
 264   2                      {
 265   3                              if (rxbuf[2] == get_currentSensorID()) //≈–∂œ ’µΩµƒ–≈œ¢ «∑Ò–Ë“™ªÿ∏¥£¨ªÿ∏¥±ÿ–Î¥´∏–∆˜∫≈∂‘”¶
 266   3                              {
 267   4                                      sensorReplyPackage(rxbuf[2] ,rxbuf[1]);
 268   4                                      result = 1;//¥´∏–∆˜¥Ê‘⁄£¨–Ë“™ªÿ∏¥–≈œ¢
 269   4                              }
 270   3                      }
 271   2                      else
 272   2                      {
 273   3                              if (rxbuf[2] == get_currentSensorID()) //≈–∂œ ’µΩµƒ–≈œ¢ «∑Ò–Ë“™ªÿ∏¥£¨ªÿ∏¥±ÿ–Î¥´∏–∆˜∫≈∂‘”¶
 274   3                              {
 275   4                                      sensorReplyPackage(rxbuf[2] ,rxbuf[1]);
 276   4                                      result = 1;//–Ë“™ªÿ∏¥æ‡¿Î–≈œ¢
 277   4                              }
 278   3                      }
 279   2              }
 280   1              return result;
 281   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    797    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    110    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12      27
=======
 164   1              for (i = 0; i < len; i++)
 165   1              {
 166   2                      TX2_write2buff(buf[i]);
 167   2              }
 168   1      }
 169          
 170          void sensorReplyPackage(unsigned char ch, unsigned char cmd)
 171          {
 172   1              unsigned char temp_txLen = 0;
 173   1              if(cmd == CMD_ID)
 174   1              {
 175   2                      txBuf[0] = 0xBB;
 176   2                      txBuf[1] = cmd;
C51 COMPILER V9.54   UART                                                                  04/23/2022 08:59:35 PAGE 4   

 177   2                      txBuf[2] = ch;
 178   2                      txBuf[3] = 0xBF;
 179   2                      temp_txLen = 4;
 180   2              }
 181   1              else
 182   1              {
 183   2                      txBuf[0] = 0xBB;
 184   2                      txBuf[1] = cmd;
 185   2                      txBuf[2] = ch;
 186   2                      txBuf[3] = Get_meterDistance()/10;
 187   2                      txBuf[4] = 0xBF;        
 188   2                      temp_txLen = 5; 
 189   2              }
 190   1              uartSendBuf(txBuf,temp_txLen);
 191   1      }
 192          
 193          unsigned char saveTotalSensorDistance[SENSOR_NUM_MAX] = {0}; //À≥–Ú∑÷±¥˙±Ì£∫◊Û£¨◊Û÷–£¨”“÷–£¨”“
 194          
 195          // cmd 0:”“¥´∏–∆˜—≠ª∑ªÒ»°∆‰À˚¥´∏–∆˜Œª÷√–≈œ¢ 1:”“¥´∏–∆˜—≠ª∑ªÒ»°∆‰À˚¥´∏–∆˜æ‡¿Î–≈œ¢
 196          // ch ∏˘æ›∫Í∂®“Â¿¥
 197          void getSensorImfo(unsigned char ch, unsigned char cmd)
 198          {
 199   1              txBuf[0] = 0xBB;
 200   1              txBuf[1] = cmd;
 201   1              txBuf[2] = ch;
 202   1              txBuf[3] = 0xBF;
 203   1              uartSendBuf(txBuf, 3);
 204   1      }
 205          
 206          //Ω” ’ ˝æ›Ω‚Œˆ∫Ø ˝
 207          // buf:Ω” ’ ˝æ›÷∏’Î
 208          // len:Ω” ’ ˝æ›≥§∂»
 209          //∏Ò Ω£∫BB + cmd + ch + distance(BYTE) + BF
 210          unsigned char analysisSensorImfo(void)
 211          {
 212   1              unsigned char result = 0;
 213   1              if (get_currentSensorID() == RIGHT_SENSOR)
 214   1              {
 215   2                      if (rxbuf[1] == CMD_ID)
 216   2                      {
 217   3                              if (rxbuf[2] == LEFT_SENSOR)
 218   3                              {
 219   4                                      result = 1;//¥´∏–∆˜¥Ê‘⁄
 220   4                              }
 221   3                              else if (rxbuf[2] == LEFT_MID_SENSOR)
 222   3                              {
 223   4                                      result = 1;//¥´∏–∆˜¥Ê‘⁄
 224   4                              }
 225   3                              else if (rxbuf[2] == RIGHT_MID_SENSOR)
 226   3                              {
 227   4                                      result = 1;//¥´∏–∆˜¥Ê‘⁄
 228   4                              }
 229   3                      }
 230   2                      else
 231   2                      {
 232   3                              if (rxbuf[2] == LEFT_SENSOR)
 233   3                              {
 234   4                                      saveTotalSensorDistance[0] = rxbuf[3] ;
 235   4                                      result = 1;//Ω‚Œˆæ‡¿Î
 236   4                              }
 237   3                              else if (rxbuf[2] == LEFT_MID_SENSOR)
 238   3                              {
C51 COMPILER V9.54   UART                                                                  04/23/2022 08:59:35 PAGE 5   

 239   4                                      saveTotalSensorDistance[1] = rxbuf[3] ;
 240   4                                      result = 1;//Ω‚Œˆæ‡¿Î
 241   4                              }
 242   3                              else if (rxbuf[2] == RIGHT_MID_SENSOR)
 243   3                              {
 244   4                                      saveTotalSensorDistance[2] = rxbuf[3] ;
 245   4                                      result = 1;//Ω‚Œˆæ‡¿Î
 246   4                              }
 247   3                      }
 248   2              }
 249   1              else
 250   1              {
 251   2                      if (rxbuf[1] == CMD_ID)
 252   2                      {
 253   3                              if (rxbuf[2] == get_currentSensorID()) //≈–∂œ ’µΩµƒ–≈œ¢ «∑Ò–Ë“™ªÿ∏¥£¨ªÿ∏¥±ÿ–Î¥´∏–∆˜∫≈∂‘”¶
 254   3                              {
 255   4                                      sensorReplyPackage(rxbuf[2] ,rxbuf[1]);
 256   4                                      result = 1;//¥´∏–∆˜¥Ê‘⁄£¨–Ë“™ªÿ∏¥–≈œ¢
 257   4                              }
 258   3                      }
 259   2                      else
 260   2                      {
 261   3                              if (rxbuf[2] == get_currentSensorID()) //≈–∂œ ’µΩµƒ–≈œ¢ «∑Ò–Ë“™ªÿ∏¥£¨ªÿ∏¥±ÿ–Î¥´∏–∆˜∫≈∂‘”¶
 262   3                              {
 263   4                                      sensorReplyPackage(rxbuf[2] ,rxbuf[1]);
 264   4                                      result = 1;//–Ë“™ªÿ∏¥æ‡¿Î–≈œ¢
 265   4                              }
 266   3                      }
 267   2              }
 268   1              return result;
 269   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    793    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    110    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12      14
>>>>>>> ac9b71b636d5bf0dc7d832531626a13307726cd8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
